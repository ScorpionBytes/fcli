package com.fortify.cli.common.output.cli.mixin;

import com.fortify.cli.common.output.cli.cmd.unirest.AbstractUnirestOutputCommand;
import com.fortify.cli.common.output.cli.mixin.spi.unirest.AbstractUnirestOutputHelper;
import com.fortify.cli.common.output.cli.mixin.spi.unirest.IUnirestOutputHelper;
import com.fortify.cli.common.output.cli.mixin.writer.OutputWriterWithQueryFactoryMixin;
import com.fortify.cli.common.output.cli.mixin.writer.StandardOutputWriterFactoryMixin;
import com.fortify.cli.common.output.spi.product.ProductHelperClass;
import com.fortify.cli.common.output.writer.output.standard.StandardOutputConfig;

import io.micronaut.core.annotation.ReflectiveAccess;
import lombok.Getter;
import lombok.Setter;
import picocli.CommandLine.Command;
import picocli.CommandLine.Mixin;
import picocli.CommandLine.Model.CommandSpec;
import picocli.CommandLine.Spec;
import picocli.CommandLine.Spec.Target;

/**
 * <p>This class provides standard, product-agnostic {@link IUnirestOutputHelper} implementations.
 * Each product module should provide a {@code <Product>OutputHelperMixins} class that has
 * a {@link ProductHelperClass} annotation for providing product-specific functionality, and 
 * provides similarly named inner classes that extend from the corresponding 
 * {@link UnirestOutputHelperMixins} inner class. For example:</p>
 * 
 * <pre>
 * @ReflectiveAccess
 * @ProductHelperClass(MyProductHelper.class)
 * public class MyProductOutputHelperMixins {
 *     public static class SCDastProductHelper implements IProductHelper, ... {
 *         @Getter @Setter private IUnirestOutputHelper outputHelper;
 *         ...
 *     }
 *     
 *     @ReflectiveAccess public static class Create 
 *         extends UnirestOutputHelperMixins.Create {}
 *     
 *     ...
 * }
 * </pre>
 * 
 * <p>Each product-specific {@link Command} implementation can then use the appropriate 
 * product-specific {@link IUnirestOutputHelper} implementation through the {@link Mixin} 
 * annotation, i.e.:</p>
 * 
 * <pre>
 * &#64;ReflectiveAccess
 * &#64;Command(name = MyProductOutputHelperMixins.List.CMD_NAME)
 * public class SomeListCommand extends AbstractMyProductOutputCommand implements IBaseHttpRequestSupplier {
 *     &#64;Getter &#64;Mixin private MyProductOutputHelperMixins.List outputHelper;
 *     ...
 * }
 * </pre>
 * 
 * <p>Here, {@code AbstractMyProductOutputCommand} would extend from {@link AbstractUnirestOutputCommand},
 * which takes care of displaying the output generated by the command, based on the configured
 * {@link IUnirestOutputHelper} {@link Mixin}.</p>
 * 
 * <p>For consistency, command implementations should use the {@link IUnirestOutputHelper} implementation
 * that exactly matches the command. For example, you should only be using the {@link List}
 * implementation if you are actually implementing a 'list' command; {@link List} shouldn't be used
 * by commands that just generate some list of output but are not actually called 'list'. In other
 * words, the command name should match the {@code CMD_NAME} provided by the {@link IUnirestOutputHelper}
 * implementation (and you should always use that constant to define the {@link Command} name.</p>
 * 
 * If there is no matching standard {@link IUnirestOutputHelper} mixin class, the 
 * {@code MyProductOutputHelperMixins} class can define additional, product-specific
 * {@link IUnirestOutputHelper} mixins that extend from one of the following generic 
 * mixins:
 * <ul>
 * <li>{@link Other}, not providing any standard output format or output writer factory; subclass should provide {@code CMD_NAME} constant, and outputWriterFactory and basicOutputConfig fields with Getter annotations</li>
 * <li>{@link TableWithQuery}, providing query options and default table output format; subclass should provide {@code CMD_NAME} constant</li>
 * <li>{@link TableNoQuery}, providing no query options and default table output format; subclass should provide {@code CMD_NAME} constant</li>
 * </ul>
 * 
 * All standard output helper mixins defined in this class are based on {@code TableNoQuery}, except
 * for the {@code List} class which is based on {@code TableWithQuery}.
 *    
 * @author rsenden
 */
public class UnirestOutputHelperMixins {
    @ReflectiveAccess @Command
    public static class Other extends AbstractUnirestOutputHelper {
        @Getter @Setter(onMethod=@__({@Spec(Target.MIXEE)})) private CommandSpec mixee;
    }
    
    @ReflectiveAccess
    public static class TableWithQuery extends Other {
        @Getter @Mixin private OutputWriterWithQueryFactoryMixin outputWriterFactory;
        @Getter private StandardOutputConfig basicOutputConfig = StandardOutputConfig.table(); 
    }
    
    @ReflectiveAccess
    public static class TableNoQuery extends Other {
        @Getter @Mixin private StandardOutputWriterFactoryMixin outputWriterFactory;
        @Getter private StandardOutputConfig basicOutputConfig = StandardOutputConfig.table(); 
    }
    
    @ReflectiveAccess
    public static class Add extends TableNoQuery {
        public static final String CMD_NAME = "add";
    }
    
    @ReflectiveAccess
    public static class Create extends TableNoQuery {
        public static final String CMD_NAME = "create";
    }
    
    @ReflectiveAccess @Command(aliases = {"rm"})
    public static class Delete extends TableNoQuery {
        public static final String CMD_NAME = "delete";
    }
    
    @ReflectiveAccess @Command(aliases = {"clear"})
    public static class DeleteAll extends TableNoQuery {
        public static final String CMD_NAME = "delete-all";
    }
    
    @ReflectiveAccess @Command(name = "list", aliases = {"ls"})
    public static class List extends TableWithQuery {
        public static final String CMD_NAME = "list";
    }
    
    @ReflectiveAccess
    public static class Get extends TableNoQuery {
        public static final String CMD_NAME = "get";
    }
    
    @ReflectiveAccess
    public static class Set extends TableNoQuery {
        public static final String CMD_NAME = "set";
   }
    
    @ReflectiveAccess
    public static class Update extends TableNoQuery {
        public static final String CMD_NAME = "update";
    }
    
    @ReflectiveAccess
    public static class Enable extends TableNoQuery {
        public static final String CMD_NAME = "enable";
    }
    
    @ReflectiveAccess
    public static class Disable extends TableNoQuery {
        public static final String CMD_NAME = "disable";
    }
    
    @ReflectiveAccess
    public static class Start extends TableNoQuery {
        public static final String CMD_NAME = "start";
    }
    
    @ReflectiveAccess
    public static class Pause extends TableNoQuery {
        public static final String CMD_NAME = "pause";
    }
    
    @ReflectiveAccess
    public static class Resume extends TableNoQuery {
        public static final String CMD_NAME = "resume";
    }
    
    @ReflectiveAccess
    public static class Cancel extends TableNoQuery {
        public static final String CMD_NAME = "cancel";
    }

    @ReflectiveAccess
    public static class Upload extends TableNoQuery {
        public static final String CMD_NAME = "upload";
    }
    
    @ReflectiveAccess
    public static class Download extends TableNoQuery {
        public static final String CMD_NAME = "download";
    }
    
    @ReflectiveAccess
    public static class Install extends TableNoQuery {
        public static final String CMD_NAME = "install";
    }
    
    @ReflectiveAccess
    public static class Uninstall extends TableNoQuery {
        public static final String CMD_NAME = "uninstall";
    }

    @ReflectiveAccess
    public static class Import extends TableNoQuery {
        public static final String CMD_NAME = "import";
    }

    @ReflectiveAccess
    public static class Export extends TableNoQuery {
        public static final String CMD_NAME = "export";
    }

    @ReflectiveAccess
    public static class Setup extends TableNoQuery {
        public static final String CMD_NAME = "setup";
    }
}
